package docker

import (
	"bytes"
	"context"
	"io"
	"strconv"
	"strings"

	"github.com/cuigh/swirl/misc"
	"github.com/docker/docker/api/types"
	"github.com/docker/docker/api/types/container"
	"github.com/docker/docker/api/types/filters"
	"github.com/docker/docker/client"
	"github.com/docker/docker/pkg/stdcopy"
)

// ContainerList return containers on the host.
func (d *Docker) ContainerList(ctx context.Context, node, name, status string, pageIndex, pageSize int) (containers []container.Summary, total int, err error) {
	var c *client.Client
	c, err = d.agent(node)
	if err != nil {
		return
	}

	opts := container.ListOptions{Filters: filters.NewArgs()}
	if status == "" {
		opts.All = true
	} else {
		opts.Filters.Add("status", status)
	}
	if name != "" {
		opts.Filters.Add("name", name)
	}

	containers, err = c.ContainerList(ctx, opts)
	if err == nil {
		total = len(containers)
		start, end := misc.Page(total, pageIndex, pageSize)
		containers = containers[start:end]
	}
	return
}

// ContainerInspect return container raw information.
func (d *Docker) ContainerInspect(ctx context.Context, node, id string) (container container.InspectResponse, raw []byte, err error) {
	var c *client.Client
	if c, err = d.agent(node); err == nil {
		container, raw, err = c.ContainerInspectWithRaw(ctx, id, true)
	}
	return
}

// ContainerRemove remove a container.
func (d *Docker) ContainerRemove(ctx context.Context, node, id string) (err error) {
	var c *client.Client
	if c, err = d.agent(node); err == nil {
		err = c.ContainerRemove(ctx, id, container.RemoveOptions{})
	}
	return
}

// ContainerExecCreate creates an exec instance.
func (d *Docker) ContainerExecCreate(ctx context.Context, node, id string, cmd string) (resp container.ExecCreateResponse, err error) {
	var c *client.Client
	c, err = d.agent(node)
	if err != nil {
		return
	}

	opts := container.ExecOptions{
		AttachStdin:  true,
		AttachStdout: true,
		AttachStderr: true,
		Tty:          true,
		//User: "root",
		Cmd: strings.Split(cmd, " "),
	}
	resp, err = c.ContainerExecCreate(ctx, id, opts)
	return
}

// ContainerExecAttach attaches a connection to an exec process in the server.
func (d *Docker) ContainerExecAttach(ctx context.Context, node, id string) (resp types.HijackedResponse, err error) {
	var c *client.Client
	c, err = d.agent(node)
	if err != nil {
		return
	}

	opts := container.ExecAttachOptions{
		Detach: false,
		Tty:    true,
	}
	resp, err = c.ContainerExecAttach(ctx, id, opts)
	return
}

// ContainerExecStart starts an exec instance.
func (d *Docker) ContainerExecStart(ctx context.Context, node, id string) (err error) {
	c, err := d.agent(node)
	if err != nil {
		return err
	}

	opts := container.ExecStartOptions{
		Detach: false,
		Tty:    true,
	}
	return c.ContainerExecStart(ctx, id, opts)
}

// ContainerLogs returns the logs generated by a container.
func (d *Docker) ContainerLogs(ctx context.Context, node, id string, lines int, timestamps bool) (stdout, stderr *bytes.Buffer, err error) {
	var c *client.Client
	c, err = d.agent(node)
	if err != nil {
		return
	}

	var (
		rc   io.ReadCloser
		opts = container.LogsOptions{
			ShowStdout: true,
			ShowStderr: true,
			Tail:       strconv.Itoa(lines),
			Timestamps: timestamps,
			//Since: (time.Hour * 24).String()
		}
	)
	if rc, err = c.ContainerLogs(ctx, id, opts); err == nil {
		defer rc.Close()

		stdout = &bytes.Buffer{}
		stderr = &bytes.Buffer{}
		_, err = stdcopy.StdCopy(stdout, stderr, rc)
	}
	return
}

// ContainerPrune remove all unused containers.
func (d *Docker) ContainerPrune(ctx context.Context, node string) (report container.PruneReport, err error) {
	var c *client.Client
	if c, err = d.agent(node); err == nil {
		report, err = c.ContainersPrune(ctx, filters.NewArgs())
	}
	return
}
